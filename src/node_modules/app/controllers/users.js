const { groupBy, get } = require('lodash');

const {
  NoMoreTicketsError,
  UserIdMismatchError,
  NotFoundError,
} = require('app/errors');

module.exports = (service) => ({
  get: async (p, q, b, user) => {
    const tickets = await service.db
      .collection('tickets')
      .where('user', '==', service.db.doc(`users/${user.id}`))
      .get();
    const userData = await service.db
      .collection('users')
      .doc(user.id)
      .get();

    return Object.assign({}, userData.data(), {
      tickets: {
        total: user.tickets,
        remaining: user.tickets - tickets.docs.length,
      },
      iat: undefined, // blank out the iat from the token
      id: user.id,
    });
  },
  getPrizes: async (p, q, b, user) => {
    const tickets = await service.db
      .collection('tickets')
      .where('user', '==', service.db.doc(`users/${user.id}`))
      .get();

    const userPrizes = await Promise.all(tickets.docs.map(async (ticket) => {
      const prize = await ticket.data().prize.get();
      return Object.assign({}, prize.data(), { id: prize.id });
    }));

    const prizes = groupBy(userPrizes, 'id');

    return Object.keys(prizes).map((key) => Object.assign({}, prizes[key][0], {
      committedTickets: prizes[key].length,
    }));
  },
  commitTicket: async (p, q, body, userData) => {
    const { prize, user } = get(body, 'data.attributes');

    if (user !== userData.id) {
      throw new UserIdMismatchError(userData.id, user);
    }

    const existingPrize = await service.db
      .collection('prizes')
      .doc(prize)
      .get();

    if (!existingPrize) {
      throw new NotFoundError();
    }

    const tickets = await service.db
      .collection('tickets')
      .where('user', '==', service.db.doc(`users/${userData.id}`))
      .get();

    if ((userData.tickets - tickets.docs.length) < 1) {
      throw new NoMoreTicketsError();
    }

    const created = new Date();

    const newTicket = await service.db.collection('tickets')
      .add({
        user: service.db.doc(`users/${user}`),
        prize: service.db.doc(`prizes/${prize}`),
        created,
      });

    return {
      id: newTicket.id,
      user,
      prize,
      created,
    };
  },
});