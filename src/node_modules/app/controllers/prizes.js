const uuidv4 = require("uuid/v4");

const { NotFoundError } = require("app/errors");

const getStorageUrl = require("../utils/getStorageUrl");

const convertToOuputCase = prize => ({
  id: prize.id,
  categoryId: prize.category_id,
  title: prize.title,
  description: prize.description,
  image: prize.image_key ? getStorageUrl(prize.image_key) : null,
  committedTickets: prize.committed_tickets
});

module.exports = service => ({
  getAll: async () => {
    const prizes = await service.db.query(
      `
      SELECT id, category_id, title, description, image_key, committed_tickets
      FROM PRIZES P 
        JOIN (SELECT prize_id, COUNT(*) AS committed_tickets FROM TICKETS GROUP BY prize_id) T
        ON P.id = T.prize_id
      `
    );

    return prizes.map(convertToOuputCase);
  },
  get: async ({ id }) => {
    const prizes = await service.db.query(
      `
      SELECT id, category_id, title, description, image_key, committed_tickets
      FROM PRIZES P
        JOIN (SELECT prize_id, COUNT(*) AS committed_tickets FROM TICKETS WHERE prize_id = ? GROUP BY prize_id) T
        ON P.id = T.prize_id
      WHERE P.id = ?
      `,
      [id, id]
    );

    if (prizes.length === 0) {
      throw new NotFoundError();
    }

    return convertToOuputCase(prizes[0]);
  },
  getDiffs: async (p, { since }) => {
    const prizesWithNewTickets = await service.db.query(
      `
      SELECT id, category_id, title, description, image_key, committed_tickets
      FROM PRIZES P
        INNER JOIN (
          SELECT prize_id, COUNT(*) AS committed_tickets
          FROM TICKETS
          WHERE prize_id IN (SELECT prize_id FROM TICKETS WHERE created > ?)
          GROUP BY prize_id
        ) T
        ON P.id = T.prize_id
      `,
      new Date(since)
        .toISOString()
        .replace(/T/, " ") // replace T with a space
        .replace(/\..+/, "") // delete the dot and everything after
    );

    return prizesWithNewTickets.map(convertToOuputCase);
  },
  update: async ({ id }, q, body, u, req) => {
    const { categoryId, title, description, removeImage } = body;

    if (!categoryId || !title || !description) {
      throw new MissingParamsError([
        "categoryId",
        "title",
        "description",
        "removeImage"
      ]);
    }

    let prizes = await service.db.query(
      `SELECT id, category_id, title, description, image_key FROM PRIZES WHERE id = ?`,
      id
    );

    if (prizes.length === 0) {
      throw new NotFoundError();
    }

    const { file } = req;
    let imageKey = prizes[0].image_key;

    if ((file || removeImage) && imageKey != null && imageKey != "") {
      try {
        await service.bucket.file(imageKey).delete();
      } catch (e) {
        console.log(`Error deleting photo '${imageKey}'`, e);
      }

      imageKey = null;
    }

    if (file) {
      imageKey = `photos/${uuidv4()}`;

      try {
        await service.bucket.file(imageKey).save(file.buffer, {
          contentType: file.mimetype
        });
      } catch (e) {
        console.log(`Error uploading photo '${imageKey}'`, e);
        imageKey = null;
      }
    }

    await service.db.query(
      `UPDATE PRIZES SET image_key = ?, category_id = ?, title = ?, description = ? WHERE id = ?`,
      [imageKey, categoryId, title, description, id]
    );

    prizes = await service.db.query(
      `SELECT id, category_id, title, description, image_key FROM PRIZES WHERE id = ?`,
      id
    );

    if (prizes.length === 0) {
      throw new NotFoundError();
    }

    return convertToOuputCase(prizes[0]);
  },
  new: async (p, q, body, u, req) => {
    const { categoryId, title, description } = body;

    if (!categoryId || !title || !description) {
      throw new MissingParamsError(["categoryId", "title", "description"]);
    }

    const { file } = req;
    let imageKey = null;

    if (file) {
      imageKey = `photos/${uuidv4()}`;

      try {
        await service.bucket.file(imageKey).save(file.buffer, {
          contentType: file.mimetype
        });
      } catch (e) {
        console.log(`Error uploading photo '${imageKey}'`, e);
        imageKey = null;
      }
    }

    const results = await service.db.query(
      `INSERT INTO PRIZES(category_id, title, description, image_key) VALUES (?, ?, ?, ?)`,
      [categoryId, title, description, imageKey]
    );

    const prizes = await service.db.query(
      `SELECT id, category_id, title, description, image_key FROM PRIZES WHERE id = ?`,
      results.insertId
    );

    if (prizes.length === 0) {
      throw new NotFoundError();
    }

    return convertToOuputCase(prizes[0]);
  },
  delete: async ({ id }) => {
    const prizes = await service.db.query(
      `SELECT * FROM PRIZES WHERE id = ?`,
      id
    );

    if (prizes.length === 0) {
      throw new NotFoundError();
    }

    const imageKey = prizes[0].image_key;

    if (imageKey != null && imageKey != "") {
      try {
        await service.bucket.file(imageKey).delete();
      } catch (e) {
        console.log(`Error deleting photo '${imageKey}'`, e);
      }
    }

    await service.db.query(`DELETE FROM PRIZES WHERE id = ?`, id);

    return convertToOuputCase(prizes[0]);
  }
});
